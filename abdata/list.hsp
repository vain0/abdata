#ifndef ig_abdata_list_hsp
#define ig_abdata_list_hsp

#include "abheader.hsp"
#include "abelem.hsp"
#include "mod_nullmod.hsp"
#include "mod_shiftArray.hsp"
#include "mod_pvalptr.hsp"
#include "mod_swap.hsp"
#include "mod_ref.hsp"
#include "mod_compare.hsp"

#module abdata_list_impl mCnt, mElems, midlist

#define true  1
#define false 0
#define int_max 0x7FFFFFFF

#define ctype STR_ERR_OVER_RANGE(%1) "Error! [abdata コンテナ] 要素番号範囲外エラー(" + (%1) + ")"

#enum global SortMode_Ascending = 0
#enum global SortMode_Decending = 1

#define global listImpl_new(%1, %2, %3) newmod %1, abdata_list_impl@, %2, %3
#define global listImpl_delete(%1) delmod %1

//------------------------------------------------
// [i] 構築
// 
// @prm num      : num 個の要素を既に確保した状態で生成する。
// @prm vDefault : 確保する値の初期値
//------------------------------------------------
#modinit int num, var vDefault
	if ( num <= 0 ) {
		dimtype mElems, 5
		
	} else {
		repeat num
			abelem_new mElems, vDefault
			midlist(cnt) = cnt
			mCnt ++
		loop
	}
	
	return getaptr(thismod)
	
//------------------------------------------------
// 値の取得 ( 命令形式 )
//------------------------------------------------
#modfunc listImpl_getv_ var result, int _i, int bRemove,  local i
	
	i = listImpl_getRealIndex(thismod, _i)
	
	abelem_getv mElems( midlist(i) ), result
	
	if ( bRemove ) {
		listImpl_erase thismod, i
	}
	
	return
	
#define global listImpl_getv(%1,%2,%3=0) listImpl_getv_ %1, %2, %3, 0
#define global listImpl_popv(%1,%2,%3=0) listImpl_getv_ %1, %2, %3, 1

//------------------------------------------------
// 値の取得 ( 関数形式 )
//------------------------------------------------
#modcfunc listImpl_get_ int i, int bRemove,  local tmp
	listImpl_getv_ thismod, tmp, i, bRemove
	return tmp
	
#define global ctype listImpl_get(%1,%2=0) listImpl_get_(%1, %2, 0)
#define global ctype listImpl_pop(%1,%2=0) listImpl_get_(%1, %2, 1)

//------------------------------------------------
// 参照化 ( 命令形式 )
//------------------------------------------------
#modfunc listImpl_clone var vRef, int i
	abelem_clone mElems( midlist( listImpl_getRealIndex(thismod, i) ) ), vRef
	return
	
#modfunc listImpl_clone_abelem var ref, int i
	dup ref, mElems(midlist(i))
	return
	
//------------------------------------------------
// 参照化 ( 関数形式 )
//------------------------------------------------
#define global ctype listImpl_ref(%1, %2) \
	ref_ref_expr_template_2(listImpl_ref_, %1, %2)

#modcfunc listImpl_ref_ array ref, int i
	listImpl_clone thismod, ref, i
	return 0
	
//------------------------------------------------
// 先頭・末尾の値の取得
// 
// @ get 処理 >> const な操作
// @ pop 処理 >> 要素は取り除かれる
//------------------------------------------------
#define global ctype listImpl_get_front(%1)     listImpl_get(%1, 0)
#define global ctype listImpl_get_back(%1)      listImpl_get(%1, -1)
#define global       listImpl_getv_front(%1,%2) listImpl_getv %1, %2, 0
#define global       listImpl_getv_back(%1,%2)  listImpl_getv %1, %2, -1
#define global ctype listImpl_pop_front(%1)     listImpl_pop(%1, 0)
#define global ctype listImpl_pop_back(%1)      listImpl_pop(%1, -1)
#define global       listImpl_popv_front(%1,%2) listImpl_popv %1, %2, 0
#define global       listImpl_popv_back(%1,%2)  listImpl_popv %1, %2, -1

//------------------------------------------------
// 型の取得 ( 関数形式 )
//------------------------------------------------
#modcfunc listImpl_vartype int i
	return abelem_vartype( mElems(midlist(listImpl_getRealIndex(thismod, i))) )
	
#define global ctype listImpl_vartype_front(%1) listImpl_vartype(%1, 0)
#define global ctype listImpl_vartype_back(%1)  listImpl_vartype(%1, -1)

//------------------------------------------------
// 値の設定
//------------------------------------------------
#define global listImpl_set(%1,%2,%3=0) %tabdata \
	_cat@__abdata(%i,@__tmp) = %2 :\
	listImpl_setv %1, _cat@__abdata(%o,@__tmp), %3
	
#modfunc listImpl_setv var vValue, int i,  local iv
	
	iv = midlist( listImpl_getRealIndex(thismod, i) )
	
	// 適切に型を変換する
	abelem_changeVartype mElems(iv), vartype(vValue)
	abelem_setv          mElems(iv), vValue
	return
	
//------------------------------------------------
// 挿入
// 
// @permit (i == mCnt) : 最後尾への追加のため
// @ i が範囲外 => {
// @	( i <     0 ) => i += mCnt,
// @	( i >= mCnt ) => ([i] まで要素を自動拡張)
// @ };
//------------------------------------------------
#define global listImpl_insert(%1,%2,%3=0) %tabdata \
	_cat@__abdata(%i,@__tmp) = %2 :\
	listImpl_insertv %1, _cat@__abdata(%o,@__tmp), %3
	
#modfunc listImpl_insertv var vValue, int _i,  local i, local id
	i = _i
	if ( _i < 0 ) {
		i += mCnt
	} else : if ( _i > mCnt ) {
		logmes "abdata 要素を自動拡張 [" + mCnt + ", " + _i + "]"
		repeat _i - mCnt, mCnt
			listImpl_insertv thismod, stt_zero@, cnt
		loop
		i = _i
	} else {
		i = _i
	}
	
	stdarray_insert_room midlist, i
	
	// 新規値を追加
;	id         = GetNextAddIndex( mElems )
	abelem_new mElems, vValue
	midlist(i) = stat	;id
	mCnt ++
	return
	
//------------------------------------------------
// 先頭・最後尾への追加
//------------------------------------------------
#define global listImpl_push_front(%1,%2)  listImpl_insert  %1, %2, 0
#define global listImpl_pushv_front(%1,%2) listImpl_insertv %1, %2, 0
#define global listImpl_push_back(%1,%2)   listImpl_insert  %1, %2, listImpl_size(%1)
#define global listImpl_pushv_back(%1,%2)  listImpl_insertv %1, %2, listImpl_size(%1)
#define global listImpl_push               listImpl_push_back
#define global listImpl_pushv              listImpl_pushv_back
#define global listImpl_add                listImpl_push_back

//------------------------------------------------
// 除去
//------------------------------------------------
#modfunc listImpl_erase int _i,  local i
	i = listImpl_getRealIndex(thismod, _i)
	listImpl_erase_range thismod, i, i + 1
	return
	
#define global listImpl_erase_front(%1) listImpl_erase %1, 0
#define global listImpl_erase_back(%1)  listImpl_erase %1, (-1)

#modfunc listImpl_erase_range int lb, int ub
	if ( ub <= lb ) { return }
	repeat mCnt - ub, lb
		if ( cnt < ub ) {
			abelem_delete mElems(midlist(cnt))
		}
		midlist(cnt) = midlist(cnt + (ub - lb))
	loop
	mCnt -= (ub - lb)
	return
	
//------------------------------------------------
// 要素数の設定
// 
// @result: 元の要素数
//------------------------------------------------
#define global listImpl_resize(%1, %2, %3) \
	listImpl_resize_ (%1), (%2), (%3)

#modfunc listImpl_resize_ int newlen, var initValue,  \
	local dif
	
	dif = newlen - mCnt
	
	if ( dif < 0 ) {
		if ( newlen <= 0 ) {
			listImpl_clear thismod
			
		} else {
			// 要素 [newlen] 以降を除去
			repeat -dif, newlen
				abelem_delete mElems( midlist(cnt) )
				midlist(cnt) = -1 // nullify
			loop
		}
		
	} else : if ( dif > 0 ) {
		// 新要素を dif 個生成し、末尾に追加する
		repeat dif, newlen - dif
			abelem_new mElems, initValue
			midlist(cnt) = stat	;id
		loop
	}
	
	mCnt = newlen
	return newlen - dif
	
//------------------------------------------------
// 移動
//------------------------------------------------
#modfunc listImpl_iter_move int iSrc, int iDst
	abAssert ( listImpl_size(thismod) >= 2 ), "iter_move には少なくとも2要素が必要"
	
	stdarray_iter_move midlist, listImpl_getRealIndex(thismod, iSrc), listImpl_getRealIndex(thismod, iDst)
	return
	
//------------------------------------------------
// 交換
//------------------------------------------------
#modfunc listImpl_iter_swap int iPos1, int iPos2
	abAssert ( listImpl_size(thismod) >= 2 ), "iter_swap には少なくとも2要素が必要"
	
	stdarray_iter_swap midlist, listImpl_getRealIndex(thismod, iPos1), listImpl_getRealIndex(thismod, iPos2)
	return
	
#define global listImpl_iter_swap_front(%1) listImpl_iter_swap %1,  0,  1
#define global listImpl_iter_swap_back(%1)  listImpl_iter_swap %1, -2, -1

//------------------------------------------------
// 巡回
//------------------------------------------------
#modfunc listImpl_rotateImpl int iBgn, int _iEnd, int dir,  local iEnd
	if ( _iEnd == stdarray_index_of_end ) { iEnd = listImpl_size(thismod) } else { iEnd = _iEnd }
	stdarray_rotate_step midlist, iBgn, iEnd, dir
	return
	
#define global listImpl_rotate(     %1, %2 = 0, %3 = stdarray_index_of_end) listImpl_rotateImpl %1, %2, %3,  1
#define global listImpl_rotate_back(%1, %2 = 0, %3 = stdarray_index_of_end) listImpl_rotateImpl %1, %2, %3, -1

//------------------------------------------------
// 反転
//------------------------------------------------
#define global listImpl_reverse(%1, %2 = 0, %3 = stdarray_index_of_end) listImpl_reverse_ %1, %2, %3
#modfunc listImpl_reverse_ int iBgn, int _iEnd,  local iEnd
	if ( _iEnd == stdarray_index_of_end ) { iEnd = listImpl_size(thismod) } else { iEnd = _iEnd }
	stdarray_reverse midlist, iBgn, iEnd
	return
	
//------------------------------------------------
// [i] 完全消去
//------------------------------------------------
#modfunc listImpl_clear
	
	dimtype mElems, 5
	dim midlist
	mCnt = 0
	return
	
//------------------------------------------------
// [i] 連結
//------------------------------------------------
#modfunc listImpl_chain var src,  local tmp, local offset
	offset = mCnt
 	repeat listImpl_size( src )
		listImpl_getv       src, tmp, cnt
		listImpl_insert thismod, tmp, cnt + offset
	loop
	return
	
//------------------------------------------------
// [i] 複写
//------------------------------------------------
#modfunc listImpl_copy var src
	listImpl_clear thismod
	listImpl_chain thismod, src
	return
	
//------------------------------------------------
// [i] 交換
//------------------------------------------------
#modfunc listImpl_swap var rhs
	listImpl_swap_impl@abdata_list_impl rhs, mCnt, mElems, midlist
	return
	
#modfunc listImpl_swap_impl@abdata_list_impl array lhs_cnt, array lhs_elems, array lhs_idlist
	swap_int   mCnt,    lhs_cnt
	swap_array mElems,  lhs_elems
	swap_array midlist, lhs_idlist
	return
	
//------------------------------------------------
// 辞書順比較
//------------------------------------------------
#modcfunc listImpl_compare var rhs
	return listImpl_compare_impl@abdata_list_impl(rhs, mCnt, mElems, midlist)
	
#modcfunc listImpl_compare_impl@abdata_list_impl int lhs_size, array lhs_elems, array lhs_idlist, \
	local cmp
	
	if ( lhs_size != mCnt ) {
		return lhs_size - mCnt
	}
	repeat lhs_size
		cmp = abelem_cmp(lhs_elems(lhs_idlist(cnt)), mElems(midlist(cnt)))
		if ( cmp != 0 ) { break }
	loop
	return cmp
	
//------------------------------------------------
// 整列
//
// @prm mode : SortMode_* (default: SortMode_Ascening)
//------------------------------------------------
#modfunc listImpl_sort int mode,  \
	local arrTmp, local arrDst, local len, \
	local p, local p1, local e1, local p2, local e2, local sizeSegment, local sizeSegMerged, \
	local cmp
	
	len = listImpl_size(thismod)
	dim     arrDst, len
	foreach arrDst
		arrDst(cnt) = cnt
	loop
	
	dim arrTmp, len
	
	// マージソート
	repeat
		sizeSegment = 1 << cnt		// 1, 2, 4, 8, ...
		
		// 2-Segment ごとにマージ
		repeat
			p  = sizeSegment * (cnt * 2)	// 2-Segment の先頭
			p1 = p							// lhs (left hand segment) 範囲 (先頭要素)
			e1 = p1 + sizeSegment			// 〃 (最終要素 + 1)
			p2 = e1							// rhs
			e2 = limit( p2 + sizeSegment, 0, len )
			sizeSegMerged = (e2 - p)		// マージ後の Segment サイズ
			
			if ( sizeSegMerged < sizeSegment ) { break }	// 閾値以下 => マージせず終了
			
			repeat sizeSegMerged
				if ( p2 >= e2 ) {			// rhs の取り出しが既に完了している
					arrTmp(cnt) = arrDst(p1) : p1 ++
				} else : if ( p1 >= e1 ) {	// lhs 〃
					arrTmp(cnt) = arrDst(p2) : p2 ++
				} else {
					// ?( 一致する or ( 左が小さく(真) 昇順(真) || 右が小さく(偽) 降順(偽) ) ) => lhs からとる
					cmp = abelem_cmp( mElems(arrDst(p1)), mElems(arrDst(p2)) )
					if ( cmp == 0 || ( (cmp < 0) == (mode == SortMode_Ascending) ) ) {
						arrTmp(cnt) = arrDst(p1) : p1 ++
					} else {
						arrTmp(cnt) = arrDst(p2) : p2 ++
					}
				}
			loop
			
			// マージされた配列をソース配列に貼り付け
			memcpy arrDst(p), arrTmp, sizeSegMerged * 4
		loop
		
		// マージ終了 (1つの Segment に纏まったため)
		if ( len <= sizeSegment ) { break }
	loop
	
	// idx-list を変更
	memcpy midlist, arrDst, len * 4
	return
	
//------------------------------------------------
// 整列済みか？
//------------------------------------------------
#modcfunc listImpl_is_sorted int sort_mode,  local is_sorted,  local clone1, local clone2
	is_sorted = true
	repeat limit(0, mCnt - 1, int_max)
		listImpl_clone thismod, clone1, cnt
		listImpl_clone thismod, clone2, cnt + 1
		if ( abdata_compare(clone1, clone2) * (1 - 2 * sort_mode) > 0 ) {
			is_sorted = false : break
		}
	loop
	return is_sorted
	
//------------------------------------------------
// 整列済みコンテナの、下界・上界をみつける
//------------------------------------------------
#modcfunc listImpl_lu_bound_@abdata_list_impl var value, int sort_mode, int finds_upper, \
	local lb, local ub, local mid, local mid_clone, local cmp
	
	assert listImpl_is_sorted(thismod, sort_mode)
	lb = -1 : ub = mCnt
	repeat
		if ( (ub - lb) <= 1 ) { break }
		mid = lb + (ub - lb) / 2
		listImpl_clone thismod, mid_clone, mid
		
		cmp = abdata_compare(mid_clone, value) * (1 - 2 * sort_mode)
		if ( ((finds_upper != 0) && cmp == 0) || cmp < 0 ) {
			lb = mid
		} else {
			ub = mid
		}
	loop
	return ub
	
#define global ctype listImpl_lb(%1, %2, %3 = SortMode_Ascending) listImpl_lu_bound_@abdata_list_impl((%1), (%2), (%3), 0)
#define global ctype listImpl_ub(%1, %2, %3 = SortMode_Ascending) listImpl_lu_bound_@abdata_list_impl((%1), (%2), (%3), 1)

#modfunc listImpl_equal_range var value, var lb, var ub, int sort_mode
	lb = listImpl_lb(thismod, value, sort_mode)
	ub = listImpl_ub(thismod, value, sort_mode)
	return
	
//------------------------------------------------
// 整列済みコンテナの、適切な位置に要素を挿入する
//
// @param value: 挿入される要素の値
// @param can_dup (true):
// これが真なら、すでに value が含まれているときも、挿入する。
//------------------------------------------------
#define global listImpl_sorted_insertv(%1, %2, %3 = true@abdata_list_impl, %4 = SortMode_Ascending) \
	listImpl_sorted_insertv_@abdata_list_impl (%1), (%2), (%3), (%4)

#modfunc listImpl_sorted_insertv_@abdata_list_impl \
	var value, int can_dup, int sort_mode,  \
	local lb, local clone
	
	lb = listImpl_lb(thismod, value, sort_mode)
	if ( can_dup == false && lb != listImpl_size(thismod) ) {
		listImpl_clone thismod, clone, lb
		if ( abdata_compare(clone, value) == 0 ) { return }
	}
	listImpl_insertv thismod, value, lb
	return
	
//------------------------------------------------
// 整列済みコンテナから、要素を除去する
//
// @param value: 除去すべき要素の値
// @param max_count (∞): 除去される要素の個数の最大値
//------------------------------------------------
#define global listImpl_sorted_erasev(%1, %2, %3 = int_max@abdata_list_impl, %4 = SortMode_Ascending) \
	listImpl_sorted_erasev_@abdata_list_impl (%1), (%2), (%3), (%4)
	
#modfunc listImpl_sorted_erasev_@abdata_list_impl \
	var value, int max_count, int sort_mode,  \
	local lb, local ub
	
	listImpl_equal_range thismod, value, lb, ub, sort_mode
	ub = lb + limit(ub - lb, 0, max_count)
	listImpl_erase_range thismod, lb, ub
	return
	
//------------------------------------------------
// [i] 反復子::初期化
//------------------------------------------------
#modfunc listImpl_iter_init var iterData
	iterData = -1
	return
	
//------------------------------------------------
// [i] 反復子::更新
//------------------------------------------------
#modcfunc listImpl_iter_next var vIt, var iterData
	iterData ++
	
	if ( listImpl_is_valid(thismod, iterData) == false ) {
		return false
	}
	
	listImpl_getv thismod, vIt, iterData
	return true
	
//------------------------------------------------
// [i] 要素数
//------------------------------------------------
#modcfunc listImpl_size
	return mCnt
	
#define global listImpl_length listImpl_size
#define global ctype listImpl_empty(%1) ( listImpl_size(%1) == 0 )

//------------------------------------------------
// 数え上げ
//------------------------------------------------
#modcfunc listImpl_count var value,  local count, local ref
	repeat mCnt
		listImpl_clone thismod, ref, cnt
		if ( abdata_compare(value, ref) == 0 ) { count ++ }
	loop
	return count

//------------------------------------------------
// 範囲チェック
//------------------------------------------------
#modcfunc listImpl_is_valid int i
	if ( 0 <= i && i < mCnt ) {
		if ( varuse( mElems(midlist(i)) ) ) {
			return true
		}
	}
	return false
	
//------------------------------------------------
// 実際の要素番号を得る
// @private
//------------------------------------------------
#modcfunc listImpl_getRealIndex@abdata_list_impl int _i,  local i
	i = _i
	
	// 循環参照
	if ( i < 0 ) {
		i += mCnt
	}
	
	abAssert ( 0 <= i && i < mCnt ), STR_ERR_OVER_RANGE(i)
	return i
	
#ifdef _DEBUG

//------------------------------------------------
// デバッグ出力
//------------------------------------------------
#define global listImpl_dbglog(%1) listImpl_dbglog_ %1, "%1"

#modfunc listImpl_dbglog_ str _ident,  local ident
	ident = _ident
	
	logmes "["+ strtrim(ident, 0, ' ') +"] debug-log"
	
	repeat listImpl_size(thismod)
		logmes strf("#%2d: ", cnt) + listImpl_get(thismod, cnt)
	loop
	
	logmes ""
	return
	
#else //defined(_DEBUG)

#define global listImpl_dbglog(%1) :

#endif //defined(_DEBUG)
	
#global

//##############################################################################
// wrapper

#define global list_ClsName "list"
#define global listNull abdataNull

#define global list_new(%1, %2 = 0, %3 = stt_zero@) %1 = list_make(%2, %3)
#define global list_delete(%1) listImpl_delete abdataInsts(%1)

#module
//------------------------------------------------
// 一時コンテナ・オブジェクトの生成
//------------------------------------------------
#defcfunc list_make_impl int num, var vDefault,  local len
	
	len = length(abdataInsts_var)
	
	// 十分に埋まっていたら自動拡張
	if ( len > 1 ) : if ( varuse(abdataInsts_var(len - 2)) ) {
		abdataInsts_var(len * 2) = abNullmod
	}
	
	listImpl_new abdataInsts_var, num, vDefault
	return stat
	
#define global ctype list_make(%1 = 0, %2 = stt_zero@) list_make_impl(%1, %2)
#global

#define global list_getv(%1, %2, %3 = 0) listImpl_getv abdataInsts(%1), %2, %3
#define global list_popv(%1, %2, %3 = 0) listImpl_popv abdataInsts(%1), %2, %3

#define global ctype list_get(%1,%2=0) listImpl_get(abdataInsts(%1), %2)
#define global ctype list_pop(%1,%2=0) listImpl_pop(abdataInsts(%1), %2)

#define global list_clone(%1,%2,%3=0) listImpl_clone abdataInsts(%1), %2, %3

#define global list_clone_abelem(%1, %2, %3) listImpl_clone_abelem abdataInsts(%1), %2, %3

#define global ctype list_ref(%1,%2=0) listImpl_ref(abdataInsts(%1),%2)

#define global ctype list_get_front(%1)     listImpl_get_front( abdataInsts(%1) )
#define global ctype list_get_back(%1)      listImpl_get_back ( abdataInsts(%1) )
#define global       list_getv_front(%1,%2) listImpl_getv_front abdataInsts(%1), %2
#define global       list_getv_back(%1,%2)  listImpl_getv_back  abdataInsts(%1), %2
#define global ctype list_pop_front(%1)     listImpl_pop_front( abdataInsts(%1) )
#define global ctype list_pop_back(%1)      listImpl_pop_back ( abdataInsts(%1) )
#define global       list_popv_front(%1,%2) listImpl_popv_front abdataInsts(%1), %2
#define global       list_popv_back(%1,%2)  listImpl_popv_back  abdataInsts(%1), %2

#define global ctype list_vartype(%1,%2)    listImpl_vartype( abdataInsts(%1), %2 )
#define global ctype list_vartype_front(%1) listImpl_vartype_front( abdataInsts(%1) )
#define global ctype list_vartype_back(%1)  listImpl_vartype_back( abdataInsts(%1) )

#define global list_set(%1, %2, %3 = 0)  listImpl_set  abdataInsts(%1), %2, %3
#define global list_setv(%1, %2, %3 = 0) listImpl_setv abdataInsts(%1), %2, %3

#define global list_insert(%1, %2, %3 = 0)  listImpl_insert  abdataInsts(%1), %2, %3
#define global list_insertv(%1, %2, %3 = 0) listImpl_insertv abdataInsts(%1), %2, %3

#define global list_push_front(%1,%2)  listImpl_push_front   abdataInsts(%1), %2
#define global list_pushv_front(%1,%2) listImpl_pushv_front  abdataInsts(%1), %2
#define global list_push_back(%1,%2)   listImpl_push_back    abdataInsts(%1), %2
#define global list_pushv_back(%1,%2)  listImpl_pushv_back   abdataInsts(%1), %2

#define global list_add   list_push_back

#define global list_erase(%1, %2)   listImpl_erase       abdataInsts(%1), %2
#define global list_erase_front(%1) listImpl_erase_front abdataInsts(%1)
#define global list_erase_back(%1)  listImpl_erase_back  abdataInsts(%1)

#define global list_resize(%1, %2, %3 = stt_zero@)  listImpl_resize abdataInsts(%1), %2, %3

#define global list_iter_move(%1, %2, %3) listImpl_iter_move       abdataInsts(%1), %2, %3
#define global list_iter_swap(%1, %2, %3) listImpl_iter_swap       abdataInsts(%1), %2, %3
#define global list_iter_swap_front(%1)   listImpl_iter_swap_front abdataInsts(%1)
#define global list_iter_swap_back(%1)    listImpl_iter_swap_back  abdataInsts(%1)

#define global list_reverse(%1, %2 = 0, %3 = stdarray_index_of_end) \
	listImpl_reverse abdataInsts(%1), %2, %3

#define global list_clear(%1)    listImpl_clear abdataInsts(%1)
#define global list_chain(%1,%2) listImpl_chain abdataInsts(%1), abdataInsts(%2)
#define global list_copy(%1,%2)  listImpl_copy abdataInsts(%1), abdataInsts(%2)
#define global list_swap(%1,%2)  listImpl_swap abdataInsts(%1), abdataInsts(%2)

#define global ctype list_compare(%1, %2) \
	listImpl_compare(abdataInsts(%1), abdataInsts(%2))

#define global list_sort(%1, %2 = SortMode_Ascending) \
	listImpl_sort abdataInsts(%1), %2

#define global ctype list_is_sorted(%1, %2 = SortMode_Ascending) \
	listImpl_is_sorted(abdataInsts(%1), %2)

#define global ctype list_lb(%1, %2, %3 = SortMode_Ascending) \
	listImpl_lb(abdataInsts(%1), %2, %3)
	
#define global ctype list_ub(%1, %2, %3 = SortMode_Ascending) \
	listImpl_ub(abdataInsts(%1), %2, %3)
	
#define global list_equal_range(%1, %2, %3, %4, %5 = SortMode_Ascending) \
	listImpl_equal_range abdataInsts(%1), %2, %3, %4, %5
	
#define global list_sorted_insertv(%1, %2, %3 = true@abdata_list_impl, %4 = SortMode_Ascending) \
	listImpl_sorted_insertv abdataInsts(%1), %2, %3, %4
	
#define global list_sorted_erasev(%1, %2, %3 = int_max@abdata_list_impl, %4 = SortMode_Ascending) \
	listImpl_sorted_erasev abdataInsts(%1), %2, %3, %4

#define global       list_iter_init(%1,%2)    listImpl_iter_init abdataInsts(%1), %2
#define global ctype list_iter_next(%1,%2,%3) listImpl_iter_next(abdataInsts(%1), %2, %3)

#define global ctype list_size(%1)      listImpl_size (abdataInsts(%1))
#define global ctype list_empty(%1)     listImpl_empty(abdataInsts(%1))
#define global ctype list_count(%1, %2) listImpl_count(abdataInsts(%1), %2)
#define global list_length list_size

#define global ctype list_is_valid(%1,%2) listImpl_is_valid(abdataInsts(%1), %2)

#define global ctype list_opCmpElem(%1,%2,%3) listImpl_opCmpElem(abdataInsts(%1), %2, %3)

#define global list_dbglog(%1) listImpl_dbglog_ abdataInsts(%1), "%1"

	// abdataInsts(0) を null として扱う。
	listNull = list_make()

#endif
