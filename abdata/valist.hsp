#ifndef ig_abdata_valist_hsp
#define ig_abdata_valist_hsp

#include "abheader.hsp"
#include "abbox.hsp"
#include "mod_shiftArray.hsp"
#include "mod_nullmod.hsp"
#include "mod_pvalptr.hsp"
#include "mod_compare.hsp"

#module abdata_valist_impl arrs_, aps_, len_

/**
arrs_(t):
	型 t の配列を持つ abbox

aps_(i):
	self が持つ i 番目の要素が、arrs_ のどこに位置しているかを表す値。
	t := ap_type(aps_(i)) は、その要素の型を表す。
	k := ap_ix  (aps_(i)) は、その要素の値の arrs_(t) における位置を表す。

len_:
	self が持つ要素の個数。
//*/

#define ctype ap_type(%1) (((%1) & 0x7F000000) >> 24)
#define ctype ap_ix(%1)    ((%1) & 0x00FFFFFF)
#define ctype ap_make(%1, %2) ((((%1) & 0x7F) << 24) | ap_ix(%2))
#define vartype_max 7

#define true 1
#define false 0
#define int_max 0x7FFFFFFF

#define ctype ap_type_at(%1) ap_type(aps_(%1))
#define ctype ap_ix_at(%1)   ap_ix(aps_(%1))

#modinit
	valistImpl_init thismod
	return getaptr(thismod)
	
#modfunc valistImpl_init

	assert vartype("struct") == 5
	dimtype arrs_, 5, vartype_max + 1
	
	abbox_new arrs_
	repeat vartype_max, 1
		abbox_new arrs_, cnt
	loop
	
	// vartype 0 is invalid
	delmod arrs_(0)
	assert varuse(arrs_(0)) == 0
	
	assert len_ == 0
	return
	
#modfunc valistImpl_clear

	dim arrs_
	dim aps_
	len_ = 0
	valistImpl_init thismod
	return
	
#modfunc valistImpl_dup_aps__ array ref_aps
	dup ref_aps, aps_
	return
	
#modcfunc valistImpl_len
	return len_
	
#modcfunc valistImpl_vartype int i
	return ap_type_at(i)
	
#modcfunc valistImpl_regular_ix int i

	if ( i == abdata_ix_end ) {
		return len_
	} else : if ( i < 0 ) {
		return (i \ len_) + len_
	}
	return i
	
/**
_unsafe_get_v thismod, result, i, removes

i 番目の要素の値を result に代入する。
removes が真なら、その要素を erase する。
//*/
#define valistImpl_unsafe_get_v(%1 = thismod, %2, %3, %4) \
	abbox_unsafe_get_v arrs_(ap_type_at(%3)), %2, ap_ix_at(%3)  :\
	if (%4) { valistImpl_erase_range %1, (%3), (%3) + 1 }       :\
	//
	
#modcfunc valistImpl_try_get var result, int i, int removes
	if ( 0 <= i && i < len_ ) {
		valistImpl_unsafe_get_v thismod, result, i, removes
		return true
	} else {
		return false
	}
	
/**
_unsafe_dup_v thismod, result, i

result を、i 番目の要素のデータへのクローン変数にする。
//*/
#define valistImpl_unsafe_dup(%1 = thismod, %2, %3) \
	abbox_unsafe_dup_v arrs_(ap_type_at(%3)), %2, ap_ix_at(%3)

#modcfunc valistImpl_try_dup array ref, int i
	if ( 0 <= i && i < len_ ) {
		valistImpl_unsafe_dup thismod, ref, i
		return true
	} else {
		return false
	}
	
#modfunc valistImpl_setv var value, int i

	assert 0 <= i && i < len_
	if ( vartype(value) == ap_type_at(i) ) {
		abbox_unsafe_set_v arrs_(ap_type_at(i)), ap_ix_at(i), value
		
	// 型が変わる場合
	// 元の要素を除去し、新しく挿入した要素へのリンクで置き換える。
	} else {
		abbox_unsafe_erase_at arrs_(ap_type_at(i)), ap_ix_at(i)
		abbox_add arrs_(vartype(value)), value
		aps_(i) = ap_make(vartype(value), stat)
	}
	return
	
#modfunc valistImpl_insertv var value, int i

	if ( i < 0 ) {
		valistImpl_insertv thismod, value, valistImpl_regular_ix(thismod, i)
		return
	}
	
	// 要素数の自動拡張
	if ( i > len_ ) {
		repeat i - len_, len_
			valistImpl_insertv thismod, stt_zero@, cnt
		loop
	}
	
	// 新要素に対応する ap を挿入
	stdarray_insert_room aps_, i
	
	// 新要素を挿入
	abbox_add arrs_(vartype(value)), value
	aps_(i) = ap_make(vartype(value), stat)
	
	len_ ++
	return
	
#modfunc valistImpl_erase_range int i_beg, int i_end

	if ( i_beg < 0 || i_end < 0 ) {
		valistImpl_erase_range thismod, valistImpl_regular_ix(thismod, i_beg), valistImpl_regular_ix(thismod, i_end)
		return
	}
	if ( i_beg >= i_end ) { return }
	
	repeat i_end - i_beg, i_beg
		abbox_unsafe_erase_at arrs_(ap_type_at(cnt)), ap_ix_at(cnt)
	loop
	
	stdarray_erase_range aps_, len_, i_beg, i_end
	len_ -= i_end - i_beg
	return
	
#modfunc valistImpl_iter_swap int i0, int i1

	assert 0 <= i0 && i0 < len_
	assert 0 <= i1 && i1 < len_
	stdarray_iter_swap aps_, i0, i1
	return
	
#modfunc valistImpl_sort int sort_mode,  \
	local p, local p1, local e1, local p2, local e2, local size_segment, local size_seg_merged, \
	local aps_tmp, local l_ref, local r_ref, local cmp
	
	dim aps_tmp, len_
	repeat
		size_segment = 1 << cnt
		
		repeat
			p  = size_segment * (cnt * 2)
			p1 = p
			e1 = p1 + size_segment
			p2 = e1
			e2 = limit(p2 + size_segment, 0, len_)
			size_seg_merged = (e2 - p)
			
			if ( size_seg_merged < size_segment ) { break }
			
			repeat size_seg_merged
				if ( p2 >= e2 ) {
					aps_tmp(cnt) = aps_(p1) : p1 ++
				} else : if ( p1 >= e1 ) {
					aps_tmp(cnt) = aps_(p2) : p2 ++
				} else {
					valistImpl_unsafe_dup thismod, l_ref, p1
					valistImpl_unsafe_dup thismod, r_ref, p2
					cmp = abdata_compare(l_ref, r_ref)
					if ( cmp == 0 || ((cmp < 0) == (sort_mode == abdata_sort_ascending)) ) {
						aps_tmp(cnt) = aps_(p1) : p1 ++
					} else {
						aps_tmp(cnt) = aps_(p2) : p2 ++
					}
				}
			loop
			
			repeat size_seg_merged
				aps_(p + cnt) = aps_tmp(cnt)
			loop
		loop
		
		if ( len_ <= size_segment ) { break }
	loop
	return
	
#global

//##############################################################################
// wrapper

#define global valist_new(%1, %2 = 0, %3 = stt_zero@) \
	%1 = valist_make_replicate(%2, %3)

#define global valist_delete(%1) \
	delmod abdataInsts(%1)

#define global ctype valist_make(%1 = 0, %2 = stt_zero@) \
	valist_make_replicate(%1, %2)
	
#define global valist_clear(%1) \
	valistImpl_clear abdataInsts(%1)

#define global ctype valist_size(%1) valistImpl_len(abdataInsts(%1))
#define global valist_length valist_size

#define global ctype valist_vartype(%1, %2) valistImpl_vartype(abdataInsts(%1), %2)

#define global ctype valist_regular_ix(%1, %2) valistImpl_regular_ix(abdataInsts(%1), %2)

#define global ctype valist_try_get(%1, %2, %3) \
	valistImpl_try_get(abdataInsts(%1), %2, %3, 0 /* removes */)

#define global ctype valist_try_pop(%1, %2, %3) \
	valistImpl_try_get(abdataInsts(%1), %2, %3, 1 /* removes */)

#define global ctype valist_get(%1, %2)  valist_get__(%1, %2, 0 /* removes */)
#define global ctype valist_pop(%1, %2)  valist_get__(%1, %2, 1 /* removes */)
#define global ctype valist_get_front(%1)  valist_get(%1, 0)
#define global ctype valist_pop_front(%1)  valist_pop(%1, 0)
#define global ctype valist_get_back(%1)   valist_get(%1, -1)
#define global ctype valist_pop_back(%1)   valist_pop(%1, -1)

#define global valist_getv(%1, %2, %3)    valist_getv__ %1, %2, %3, 0 /* removes */
#define global valist_popv(%1, %2, %3)    valist_getv__ %1, %2, %3, 1 /* removes */
#define global valist_getv_front(%1, %2)  valist_getv %1, %2, 0
#define global valist_popv_front(%1, %2)  valist_popv %1, %2, 0
#define global valist_getv_back(%1, %2)   valist_getv %1, %2, -1
#define global valist_popv_back(%1, %2)   valist_popv %1, %2, -1

#define global ctype valist_try_dup(%1, %2, %3) \
	valistImpl_try_dup(abdataInsts(%1), %2, %3)

#define global ctype valist_ref(%1, %2) %t__ref %i0 \
	_cat@__abdata(%p,@__tmp)( \
		valist_ref_impl(%1, _cat@__abdata(%p,@__tmp), (%2)) \
	) %o0 //

#define global valist_set(%1, %2, %3) %tabdata \
	_cat@__abdata(%i,@__tmp) = %2 :\
	valist_setv %1, _cat@__abdata(%o,@__tmp), %3

#define global valist_setv(%1, %2, %3) \
	valistImpl_setv abdataInsts(%1), %2, %3

#define global valist_insertv(%1, %2, %3) \
	valistImpl_insertv abdataInsts(%1), %2, %3

#define global valist_insert(%1, %2, %3) %tabdata \
	_cat@__abdata(%i,@__tmp) = %2 :\
	valist_insertv %1, _cat@__abdata(%o,@__tmp), %3

#define global valist_push_front(%1, %2)  valist_insert  (%1), %2, 0
#define global valist_pushv_front(%1, %2) valist_insertv (%1), %2, 0

#define global valist_push_back(%1, %2)   valist_insert  (%1), %2, abdata_ix_end
#define global valist_pushv_back(%1, %2)  valist_insertv (%1), %2, abdata_ix_end

#define global valist_erase_range(%1, %2, %3) \
	valistImpl_erase_range abdataInsts(%1), %2, %3

#define global valist_erase_front(%1, %2)   valist_erase_at %1, 0
#define global valist_erase_back(%1, %2)    valist_erase_at %1, -1

#define global valist_iter_swap(%1, %2, %3) \
	valistImpl_iter_swap abdataInsts(%1), %2, %3

#define global valist_reverse(%1, %2 = 0, %3 = abdata_ix_end) \
	valist_reverse__ %1, %2, %3

#define global valist_sort(%1, %2 = abdata_sort_ascending) \
	valistImpl_sort abdataInsts(%1), %2

#define global ctype valist_lb(%1, %2, %3 = abdata_sort_ascending)  valist_lb_ub__(%1, %2, %3, 0 /* finds_lb */)
#define global ctype valist_ub(%1, %2, %3 = abdata_sort_ascending)  valist_lb_ub__(%1, %2, %3, 1 /* finds_ub */)

#define global valist_sorted_insertv(%1, %2, %3 = true@abdata_valist_impl, %4 = abdata_sort_ascending) \
	valist_sorted_insertv__ %1, %2, %3, %4

#define global valist_sorted_erasev(%1, %2, %3 = int_max@abdata_valist_impl, %4 = abdata_sort_ascending) \
	valist_sorted_erasev__ %1, %2, %3, %4

#ifdef _debug
	#define global valist_dbglog(%1) valist_dbglog__ %1, "%1"
#else
	#define global valist_dbglog(%1) :
#endif //defined(_debug)

#module
#defcfunc valist_make_empty
	
	// abdataInsts_var の伸長
	#define __len length(abdataInsts_var)
		if ( __len > 1 ) : if ( varuse(abdataInsts_var(__len - 2)) ) {
			abdataInsts_var(__len * 2) = abNullmod
		}
	#undef __len
	
	newmod abdataInsts_var, abdata_valist_impl@
	return stat
#global

#module
#defcfunc valist_make_replicate int count, var value,  \
	local self
	
	self = valist_make_empty()
	repeat count
		valist_insertv self, value, cnt
	loop
	return self
#global

#module
#deffunc valist_copy int self, int rhs
	valist_clear self
	valist_chain self, rhs
	return
#global

#module
#deffunc valist_chain int self, int rhs,  \
	local i, local ref
	
	while ( valist_try_dup(rhs, ref, i) ) // avoid copying
		valist_pushv_back self, ref
		i ++
	wend
	return
#global

#module
#defcfunc valist_is_valid int self, int i
	return 0 <= i && i < valist_size(self)
#global

#module
#defcfunc valist_get__ int self, int i, int removes,  \
	local result
	
	if ( valistImpl_try_get(abdataInsts(self), result, valist_regular_ix(self, i), removes) ) {
		return result
	}
	assert : end 1
#global

#module
#deffunc valist_getv__ int self, var result, int i, int removes

	if ( valistImpl_try_get(abdataInsts(self), result, valist_regular_ix(self, i), removes) ) {
		return
	}
	assert : end 1
#global

#module
#deffunc valist_dup int self, array ref, int i
	if ( valist_try_dup(self, ref, i) ) {
		return
	}
	assert : end 1

#defcfunc valist_ref_impl int self, array ref, int i
	valist_dup self, ref, i
	return 0
#global

#module
#deffunc valist_erase_at int self, int i
	valist_erase_range self, i, i + 1
	return
#global

#module
#deffunc valist_resize int self, int new_len, var value,  \
	local len
	
	assert new_len >= 0
	len = valist_size(self)
	if ( len <= new_len ) {
		repeat new_len - len
			valist_pushv_back self, value
		loop
		
	} else {
		valist_erase_range self, new_len, len
	}
	return len
#global

#module
#deffunc valist_iter_move int self, int i_src, int i_dst,  \
	local aps
	
	assert 0 <= i_src && i_src < valist_size(self)
	assert 0 <= i_dst && i_dst < valist_size(self)
	valistImpl_dup_aps__ abdataInsts(self), aps
	stdarray_iter_move aps, i_src, i_end
	return
#global

#module
#deffunc valist_reverse__ int self, int i_beg, int i_end,  \
	local aps
	
	if ( i_end < 0 ) {
		valist_reverse__ self, i_beg, valist_regular_ix(self, i_end)
		return
	}
	assert 0 <= i_beg && i_beg <= i_end && i_end <= valist_size(self)
	valistImpl_dup_aps__ abdataInsts(self), aps
	stdarray_reverse aps, i_beg, i_end
	return
#global

#module
#defcfunc valist_compare int self, int rhs,  \
	local len, local cmp, local l_ref, local r_ref
	
	len = valist_size(self)
	cmp = len - valist_size(rhs) 
	if ( cmp ) { return cmp }
	
	repeat len
		valist_dup self, l_ref, cnt
		valist_dup rhs , r_ref, cnt
		cmp = abdata_compare(l_ref, r_ref)
		if ( cmp ) { break }
	loop
	return cmp
#global

#module
#defcfunc valist_count int self, var value,  local count, local ref
	repeat valist_size(self)
		valist_dup self, ref, cnt
		if ( abdata_compare(value, ref) == 0 ) { count ++ }
	loop
	return count
#global

#module
#defcfunc valist_is_sorted int self, int sort_mode,  \
	local i, local l_ref, local r_ref
	
	for i, 0, valist_size(self) - 1
		valist_dup self, l_ref, i
		valist_dup self, r_ref, i + 1
		if ( abdata_compare(l_ref, r_ref) * (1 - 2 * sort_mode) > 0 ) {
			return false
		}
	next
	return true
#global

#module
#defcfunc valist_lb_ub__ int self, var value, int sort_mode, int finds_ub, \
	local lb, local ub, local mid, local ref, local cmp
	
	assert valist_is_sorted(self, sort_mode)
	lb = -1 : ub = valist_size(self)
	while ( ub - lb > 1 )
		mid = lb + (ub - lb) / 2
		valist_dup self, ref, mid
		cmp = abdata_compare(ref, value) * (1 - 2 * sort_mode)
		if ( ((finds_ub != 0) && cmp == 0) || cmp < 0 ) {
			lb = mid
		} else {
			ub = mid
		}
	wend
	return ub
#global

#module
#deffunc valist_equal_range int self, var value, var lb, var ub, int sort_mode
	lb = valist_lb(self, value, sort_mode)
	ub = valist_ub(self, value, sort_mode)
	return
#global

#module
#deffunc valist_sorted_insertv__ int self, var value, int may_dup, int sort_mode,  \
	local lb, local ub
	
	valist_equal_range self, value, lb, ub, sort_mode
	if ( may_dup || lb == ub ) {
		valist_insertv self, value, ub
	}
	return
#global

#module
#deffunc valist_sorted_erasev__ int self, var value, int max_count, int sort_mode,  \
	local lb, local ub
	
	valist_equal_range self, value, lb, ub, sort_mode
	lb = ub - limit(ub - lb, 0, max_count)
	valist_erase_range self, lb, ub
	return
#global

#module
#deffunc valist_iter_init int self, var iter_data
	iter_data = -1
	return
	
#defcfunc valist_iter_next int self, var iter, var iter_data
	iter_data ++
	return valist_try_get(self, iter, iter_data)
#global

#ifdef _debug
#module
#deffunc valist_dbglog__ int self, str ident,  \
	local ref
	
	logmes "[" + ident + "] debug-log"
	repeat valist_size(self)
		valist_dup self, ref, cnt
		logmes strf("#%2d: %s", cnt, str(ref))
	loop
	logmes ""
	return
#global
#endif //defined(_debug)

#endif
